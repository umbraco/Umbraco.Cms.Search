name: $(TeamProject)_$(Build.DefinitionName)_$(SourceBranchName)_$(Date:yyyyMMdd)$(Rev:.r)

parameters:
  - name: cache_nuget
    displayName: Cache NuGet packages
    type: boolean
    default: false

variables:
  solution: src/Umbraco.Cms.Search.sln
  buildConfiguration: Release
  DOTNET_NOLOGO: true
  DOTNET_GENERATE_ASPNET_CERTIFICATE: false
  DOTNET_SKIP_FIRST_TIME_EXPERIENCE: true
  DOTNET_CLI_TELEMETRY_OPTOUT: true
  npm_config_cache: $(Pipeline.Workspace)/.npm_client

stages:
  - stage: Build
    variables:
      NUGET_PACKAGES: $(Pipeline.Workspace)/.nuget/packages
    jobs:
      - job: Build
        pool:
          vmImage: "ubuntu-latest"
        steps:
          # Checkout source (avoid shallow clone to calculate version height)
          - checkout: self
            fetchDepth: 0

          # Setup build environment
          - task: NuGetAuthenticate@1
            displayName: Authenticate NuGet

          - task: UseDotNet@2
            displayName: Use .NET SDK from global.json
            inputs:
              useGlobalJson: true

          # Client
          - task: NodeTool@0
            displayName: Use Node.js
            retryCountOnTaskFailure: 3
            inputs:
              versionSource: 'fromFile'
              versionFilePath: src/.nvmrc

          - task: Cache@2
            displayName: Cache node_modules
            inputs:
              key: '"npm_client" | "$(Agent.OS)"| $(Build.SourcesDirectory)/src/package-lock.json'
              restoreKeys: |
                "npm_client" | "$(Agent.OS)"
                "npm_client"
              path: $(npm_config_cache)

          - script: npm ci --no-fund --no-audit --prefer-offline
            displayName: Install NPM packages
            workingDirectory: src

          - script: npm run lint:errors-only
            displayName: Lint Client (errors only)
            workingDirectory: src

          - script: npm run build
            displayName: Build Client
            workingDirectory: src

          # Cache and restore NuGet packages
          - task: Cache@2
            condition: ${{ parameters.cache_nuget }}
            displayName: Cache NuGet packages
            inputs:
              key: 'nuget | "$(Agent.OS)" | **/packages.lock.json, !**/bin/**, !**/obj/**'
              restoreKeys: |
                nuget | "$(Agent.OS)"
                nuget
              path: $(NUGET_PACKAGES)

          - script: dotnet restore $(solution) --locked-mode
            displayName: Restore NuGet packages

          # Build
          - script: dotnet build $(solution) --configuration $(buildConfiguration) --no-restore -p:ContinuousIntegrationBuild=true
            displayName: Run dotnet build

          # Pack
          - script: dotnet pack $(solution) --configuration $(buildConfiguration) --no-restore --output $(Build.ArtifactStagingDirectory)/nupkg
            displayName: Run dotnet pack

          # Publish
          - task: PublishPipelineArtifact@1
            displayName: Publish NuGet packages
            inputs:
              targetPath: $(Build.ArtifactStagingDirectory)/nupkg
              artifactName: nupkg

          - task: PublishPipelineArtifact@1
            displayName: Publish build output
            inputs:
              targetPath: $(Build.SourcesDirectory)
              artifactName: build_output

  - stage: UnitTests
    displayName: Unit Tests
    dependsOn: Build
    jobs:
      - job: UnitTests
        displayName: Run Unit Tests
        pool:
          vmImage: 'windows-latest'
        steps:
          # Checkout source
          - checkout: self

          # Setup test environment
          - task: DownloadPipelineArtifact@2
            displayName: Download build artifacts
            inputs:
              artifact: build_output
              path: $(Build.SourcesDirectory)

          - task: UseDotNet@2
            displayName: Use .NET SDK from global.json
            inputs:
              useGlobalJson: true

          # Test
          - task: DotNetCoreCLI@2
            displayName: Run dotnet test
            inputs:
              command: test
              projects: "src/Umbraco.Test.Search.Unit/Umbraco.Test.Search.Unit.csproj"
              arguments: "--configuration $(buildConfiguration) --no-build"
              testRunTitle: Unit Tests - $(Agent.OS)

  - stage: IntegrationTests
    displayName: Integration Tests
    dependsOn: Build
    jobs:

      # Integration Tests (SQLite)
      - job: IntegrationTestsSQLite
        displayName: Run Integration Tests (SQLite)
        pool:
          vmImage: 'windows-latest'
        timeoutInMinutes: 60
        steps:
          - checkout: self
            submodules: false
            lfs: false,
            fetchDepth: 1
            fetchFilter: tree:0

          # Setup test environment
          - task: DownloadPipelineArtifact@2
            displayName: Download build artifacts
            inputs:
              artifact: build_output
              path: $(Build.SourcesDirectory)

          - task: UseDotNet@2
            displayName: Use .NET SDK from global.json
            inputs:
              useGlobalJson: true

          # Test
          - task: DotNetCoreCLI@2
            displayName: Run Examine tests
            inputs:
              command: test
              projects: "src/Umbraco.Test.Search.Examine.Integration/Umbraco.Test.Search.Examine.Integration.csproj"
              arguments: '--configuration $(buildConfiguration) --no-build'
              testRunTitle: Examine Integration Tests SQLite - $(Agent.OS)
          - task: DotNetCoreCLI@2
            displayName: Run Core tests
            inputs:
              command: test
              projects: "src/Umbraco.Test.Search.Integration/Umbraco.Test.Search.Integration.csproj"
              arguments: '--configuration $(buildConfiguration) --no-build'
              testRunTitle: Integration Tests SQLite - $(Agent.OS)

      # Integration Tests (SQL Server)
      - job: IntegrationTestsSQLServer
        displayName: Run Integration Tests (SQL Server)
        pool:
          vmImage: 'windows-latest'
        timeoutInMinutes: 60
        steps:
          # Setup test environment
          - task: DownloadPipelineArtifact@2
            displayName: Download build artifacts
            inputs:
              artifact: build_output
              path: $(Build.SourcesDirectory)

          - task: UseDotNet@2
            displayName: Use .NET SDK from global.json
            inputs:
              useGlobalJson: true

          # Start SQL Server
          - powershell: docker run --name mssql -d -p 1433:1433 -e "ACCEPT_EULA=Y" -e "MSSQL_SA_PASSWORD=$(SA_PASSWORD)" mcr.microsoft.com/mssql/server:2022-latest
            displayName: Start SQL Server Docker image (Linux)
            condition: and(succeeded(), eq(variables['Agent.OS'], 'Linux'))

          - powershell: |
              $maxAttempts = 12
              $attempt = 0
              $status = ""

              while (($status -ne 'running') -and ($attempt -lt $maxAttempts)) {
                Start-Sleep -Seconds 5
                # We use the docker inspect command to check the status of the container. If the container is not running, we wait 5 seconds and try again. And if reaches 12 attempts, we fail the build.
                $status = docker inspect -f '{{.State.Status}}' mssql

                if ($status -ne 'running') {
                  Write-Host "Waiting for SQL Server to be ready... Attempt $($attempt + 1)"
                  $attempt++
                }
              }

              if ($status -eq 'running') {
                Write-Host "SQL Server container is running"
                docker ps -a
              } else {
                Write-Host "SQL Server did not become ready in time. Last known status: $status"
                docker logs mssql
                exit 1
              }
            displayName: Wait for SQL Server to be ready (Linux)
            condition: and(succeeded(), eq(variables['Agent.OS'], 'Linux'))

          - pwsh: SqlLocalDB start MSSQLLocalDB
            displayName: Start SQL Server LocalDB (Windows)
            condition: and(succeeded(), eq(variables['Agent.OS'], 'Windows_NT'))

          # Test
          - task: DotNetCoreCLI@2
            displayName: Run Examine tests
            inputs:
              command: test
              projects: "src/Umbraco.Test.Search.Examine.Integration/Umbraco.Test.Search.Examine.Integration.csproj"
              arguments: '--configuration $(buildConfiguration) --no-build'
              testRunTitle: Examine Integration Tests SQL Server - $(Agent.OS)
          - task: DotNetCoreCLI@2
            displayName: Run Core tests
            inputs:
              command: test
              projects: "src/Umbraco.Test.Search.Integration/Umbraco.Test.Search.Integration.csproj"
              arguments: '--configuration $(buildConfiguration) --no-build'
              testRunTitle: Integration Tests SQL Server - $(Agent.OS)

          # Stop SQL Server
          - pwsh: docker stop mssql
            displayName: Stop SQL Server Docker image (Linux)
            condition: and(succeeded(), eq(variables['Agent.OS'], 'Linux'))

          - pwsh: SqlLocalDB stop MSSQLLocalDB
            displayName: Stop SQL Server LocalDB (Windows)
            condition: and(succeeded(), eq(variables['Agent.OS'], 'Windows_NT'))

  - stage: Dependency_Track
    displayName: Dependency Track
    dependsOn:
      - Build
      - IntegrationTests
    # Only upload the SBOM when it's from the main branch, as we don't need to for every PR.
    condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/main'))
    jobs:
      - job: sbom
        displayName: Upload SBOMs to DependencyTrack
        steps:
          - checkout: self
            fetchDepth: 0

          - task: PowerShell@2
            displayName: 'Read Version from version.json'
            inputs:
              targetType: 'inline'
              script: |
                $versionJson = Get-Content -Path "version.json" -Raw | ConvertFrom-Json
                $version = $versionJson.version
                Write-Host "Version from version.json: $version"
                Write-Host "##vso[task.setvariable variable=VersionNumber]$version"

          # NuGet SBOM
          - script: dotnet tool install --global CycloneDX
            displayName: 'Install CycloneDX .NET Tool'

          - script: dotnet CycloneDX $(solution)
            displayName: 'Generate NuGet SBOM'

          - publish: bom.xml
            artifact: sbom
            displayName: 'Publish NuGet SBOM Artifact'

          - task: upload-bom-dtrack@1
            displayName: 'Upload NuGet SBOM to Dependency-Track'
            inputs:
              bomFilePath: bom.xml
              dtrackProjName: $(Build.Repository.Name)
              dtrackProjVersion: $(VersionNumber)
              dtrackAPIKey: $(DT_API_KEY)
              dtrackURI: $(DT_API_URL)
              dtrackProjAutoCreate: true

          # NPM SBOM
          - task: NodeTool@0
            displayName: Use Node.js
            inputs:
              versionSource: 'fromFile'
              versionFilePath: src/.nvmrc

          - script: npx --yes @cyclonedx/cyclonedx-npm --package-lock-only --output-file $(Build.SourcesDirectory)/bom-npm.xml
            displayName: 'Generate NPM SBOM'
            workingDirectory: src

          - publish: bom-npm.xml
            artifact: sbom-npm
            displayName: 'Publish NPM SBOM Artifact'

          - task: upload-bom-dtrack@1
            displayName: 'Upload NPM SBOM to Dependency-Track'
            inputs:
              bomFilePath: bom-npm.xml
              dtrackProjName: $(Build.Repository.Name)-client
              dtrackProjVersion: $(VersionNumber)
              dtrackAPIKey: $(DT_API_KEY)
              dtrackURI: $(DT_API_URL)
              dtrackProjAutoCreate: true

